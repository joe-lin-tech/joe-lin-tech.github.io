<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> cs180 - introduction to algorithms and complexity | Joe Lin </title> <meta name="author" content="Joe Lin"> <meta name="description" content="course notes from summer '24"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="/assets/libs/mdb/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/libs/bootstrap-table/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="/assets/libs/google_fonts/google-fonts.css"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer rel="stylesheet" href="/assets/libs/pseudocode/pseudocode.min.css" integrity="sha256-VwMV//xgBPDyRFVSOshhRhzJRDyBmIACniLPpeXNUdc=" crossorigin="anonymous"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://joe-lin-tech.github.io/notes/cs180/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Joe</span> Lin </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item active"> <a class="nav-link" href="/notes/">notes <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">cs180 - introduction to algorithms and complexity</h1> <p class="post-description">course notes from summer '24</p> </header> <article> <h2 id="stable-matching">Stable Matching</h2> <p>A common example of a <strong>stable matching</strong> problem is that of marriage, in which we’d like to match \(n\) men with \(n\) women based on their preferences. Here, we consider the scenario of med-school student admissions to hospitals. We are given a set of preferences among hospitals and med-school students and we’d like to come up with an algorithm to match students to hospitals.</p> <dl> <dt>unstable pair</dt> <dd>hospital \(h\) and student \(s\) form an <strong>unstable pair</strong> if both <ul> <li>\(h\) prefers \(s\) to one of its admitted students</li> <li>\(s\) prefers \(h\) to assigned hospital</li> </ul> </dd> </dl> <p>In other words, an unstable pair occurs when the hospital and student both prefer each other more than their current matching. Given this, we can now define a <strong>stable matching</strong>, which is simply an assignment with no unstable pairs.</p> <dl> <dt>matching</dt> <dd>a <strong>matching</strong> \(M\) is a set of ordered pairs \(h-s\) with \(h \in H\) and \(s \in S\) such that all hospitals and students appear in at most one pair of \(M\)</dd> <dt>perfect matching</dt> <dd>a matching M is <strong>perfect</strong> if all hospitals and students are matched</dd> </dl> <p>Note that, graphically, we can think of these matchings as a <strong>bipartite graph</strong>.</p> <dl> <dt>stable matching</dt> <dd>a <strong>stable matching</strong> is a perfect matching with no unstable pairs</dd> </dl> <h3 id="gale-shapley">Gale-Shapley</h3> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Gale-Shapley}
\begin{algorithmic}
\STATE{initialize $M$ to empty matching}
\WHILE{some hospital $h$ is unmatched and hasn't offered to every student}
    \STATE $s =$ first student on $h'$s list to whom $h$ has not yet offered
    \IF{$s$ is unmatched}
        \STATE add $h$-$s$ to matching $M$
    \ELIF{$s$ prefers $h$ to current partner $h'$}
        \STATE replace $h'$-$s$ with $h$-$s$ in matching $M$
    \ELSE
        \STATE $s$ rejects $h$
    \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}
</code></pre> <p>To prove the correctness of this algorithm, we must show that it (1) terminates, (2) produces a perfect matching, and (3) results in a stable matching.</p> <ol> <li> <strong>Claim: Gale-Shapley terminates in at most \(n^2\) iterations.</strong> <ul> <li>By brief inspection, we can prove termination by noticing that the while loop will run at most \(n^2\) iterations and thus, in total, hospitals make at most \(n^2\) proposals.</li> </ul> </li> <li> <strong>Claim: Gale-Shapley produces a perfect matching.</strong> <ul> <li> <strong>Subclaim: Gale-Shapley produces a matching.</strong> Since hospitals only match with the best unmatched student, they are in at most one pair. Since students only keep the best offer, they are also in at most one pair. Because both hospitals and students appear in at most one pair, the algorithm produces a matching.</li> <li> <strong>Subclaim: All hospitals and students are matched.</strong> We can show that all hospitals are matched with a proof by contradiction. Suppose that there exists a hospital \(h\) that is unmatched at the end of the algorithm. Since there are \(n\) hospitals and \(n\) students, an unmatched hospital implies an unmatched student \(s\). This means that \(s\) was never given an offer. However, \(h\) must have offered to all \(n\) students. Thus, by contradiction, all hospitals are matched. It follows that if all hospitals are matched and every hospital is matched to at most one student, then all students are matched.</li> <li>Since Gale-Shapley produces a matching and all hospitals and students are matched, we can conclude that it produces a perfect matching.</li> </ul> </li> <li> <strong>Claim: Gale-Shapley produces a stable matching.</strong> <ul> <li>We can prove this by contradiction. Suppose the matching \(M\) from Gale-Shapley is not stable, meaning that there exists an unstable pair \(h-s\). We know that \(h\) prefers \(s\) over \(s'\) and \(s\) prefers \(h\) over \(h'\), where \(s'\) and \(h'\) are their current matches in \(M\). There are two cases for which this could occur. <ul> <li> <strong>Case 1:</strong> \(h\) never offers to \(s\) and \(h\) ends up offering to \(s'\) in \(M\). However, since \(h\) offers in order of preference, this would imply that \(h\) prefers \(s'\) over \(s\) and hence we have a contradiction.</li> <li> <strong>Case 2:</strong> \(h\) offers to \(s\), but \(s\) rejects \(h\) for \(h'\). However, this means that \(s\) prefers \(h'\) over \(h\) and hence we have a contradiction.</li> </ul> </li> <li>By contradiction, we have proven that the Gale-Shapley matching \(M\) does not have an unstable pair and thus produces a stable matching.</li> </ul> </li> </ol> <dl> <dt>valid partner</dt> <dd>a student \(s\) is a <strong>valid partner</strong> of \(h\) if there exists any stable matching with \(h-s\)</dd> </dl> <p><strong>Claim: Gale-Shapley is hospital-optimal.</strong></p> <h2 id="proof-techniques">Proof Techniques</h2> <h3 id="loop-invariants">Loop Invariants</h3> <dl> <dt>loop invariant</dt> <dd>a <strong>loop invariant</strong> is a condition that must be true before entering the loop, after each iteration, and after the loop has completed</dd> </dl> <h3 id="induction">Induction</h3> <p><strong>Claim: Any \(2n \times 2n\) board with any square removed can be tiled with L-shaped tiles for any \(n\) greater than or equal to \(1\).</strong></p> <p>We can prove this with induction.</p> <ul> <li> <strong>Base Case:</strong> For \(n = 1\), we have a \(2 \times 2\) board. By inspection, we can see that regardless of which square we remove, we can tile the remaining squares with an L-shaped tile. The four cases are shown below, in which the green square is removed and the blue squares are covered by the L-shaped tile.</li> </ul> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-between align-items-center w-50"> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[green, fill=green!50] (-1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (-1, -1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, -1) rectangle (0, 0);
        \end{tikzpicture}
        </script> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[blue, fill=blue!50] (-1, 1) rectangle (0, 0);
            \draw[green, fill=green!50] (1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (-1, -1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, -1) rectangle (0, 0);
        \end{tikzpicture}
        </script> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[blue, fill=blue!50] (-1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, 1) rectangle (0, 0);
            \draw[green, fill=green!50] (-1, -1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, -1) rectangle (0, 0);
        \end{tikzpicture}
        </script> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[blue, fill=blue!50] (-1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (1, 1) rectangle (0, 0);
            \draw[blue, fill=blue!50] (-1, -1) rectangle (0, 0);
            \draw[green, fill=green!50] (1, -1) rectangle (0, 0);
        \end{tikzpicture}
        </script> </div> </div> <ul> <li> <strong>Inductive Hypothesis:</strong> Suppose that a \(2n \times 2n\) board with any square removed can be tiled with L-shaped tiles for some \(n \geq 1\).</li> <li> <strong>Inductive Step:</strong> For the \(n + 1\) case, we have a \(2^{n + 1} \times 2^{n + 1}\) board, which we can split into four \(2^n \times 2^n\) quadrants. Now, remove any square we’d like. The quadrant that this removed square sits in is now a \(2^n \times 2^n\) board with one square removed. For the remaining quadrants, we can place an L-shaped tile at the center of the \(2^{n + 1} \times 2^{n + 1}\) board, which essentially also turns the \(3\) quadrants into \(2^n \times 2^n\) boards with one square removed. By the inductive hypothesis, we can now tile all of these quadrants with L-shaped tiles. The \(n = 2\) case is shown below, in which the green square is removed, the yellow squares are covered by \(1\) L-shaped tile that we place, and the blue squares are covered by L-shaped tiles placed as a result of our inductive hypothesis.</li> </ul> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-center align-items-center w-75"> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[green, fill=green!50] (-2, 2) rectangle (-1, 1);
            \draw[blue, fill=blue!50] (-1, 1) -- (-1, 2) -- (0, 2) -- (0, 0) -- (-2, 0) -- (-2, 1) -- cycle;
            \draw[blue, fill=blue!50] (-2, -2) -- (-2, 0) -- (-1, 0) -- (-1, -1) -- (0, -1) -- (0, -2) -- cycle;
            \draw[blue, fill=blue!50] (2, -2) -- (0, -2) -- (0, -1) -- (1, -1) -- (1, 0) -- (2, 0) -- cycle;
            \draw[blue, fill=blue!50] (2, 2) -- (2, 0) -- (1, 0) -- (1, 1) -- (0, 1) -- (0, 2) -- cycle;
            \draw[red, fill=red!50] (-1, 0) -- (-1, -1) -- (1, -1) -- (1, 1) -- (0, 1) -- (0, 0) -- cycle;
        \end{tikzpicture}
        </script> </div> </div> <h2 id="asymptotic-notation">Asymptotic Notation</h2> <dl> <dt>big-o</dt> <dd>\(O(g(n))\) is the set of all functions \(f(n)\) such that there exists positive constants \(c\) and \(n_0\), where for any \(n \geq n_0\), we have \(0 \leq f(n) \leq c \cdot g(n)\)</dd> </dl> <p>Equivalently, \(f(n) \in O(g(n))\) if and only if \(\lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} \lt \infty\).</p> <dl> <dt>big-omega</dt> <dd>\(\Omega(g(n))\) is the set of all functions \(f(n)\) such that there exists positive constants \(c\) and \(n_0\), where for any \(n \geq n_0\), we have \(0 \leq c \cdot g(n) \leq f(n)\)</dd> </dl> <p>We can also use the limit rule definition, which says \(f(n) \in \Omega(g(n))\) if and only if \(\lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} &gt; 0\).</p> <dl> <dt>big-theta</dt> <dd>\(\Theta(g(n))\) is the set of all functions \(f(n)\) such that there exists positive constants \(c_1, c_2\) and \(n_0\), where for any \(n \geq n_0\), we have \(0 \leq c_1 \cdot g(n) \leq f(n) \leq c_n \cdot g(n)\)</dd> </dl> <p>The limit rule definition tells us that \(f(n) \in \Theta(g(n))\) if and only if \(\lim_{n \rightarrow \infty} \frac{f(n)}{g(n)} = k\) for some positive constant \(k\).</p> <p>A general <strong>hierarchy of functions</strong> exists: constant → logarithmic → polynomial → exponential. When ordering functions, we can first identify which broad category they belong to and then order each class of functions. For instance, we want to rank the following functions: \(\log{n^n}, n^2, 2^{\log{n}}, \log^2n, n^n, n^{\log{n}}, 2^n, 2^{1000}, n^{\sqrt{2}}\).</p> <table> <thead> <tr> <th style="text-align: left">Constant</th> <th style="text-align: left">Logarithmic</th> <th style="text-align: left">Polynomial</th> <th style="text-align: left">Exponential</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">\(2^{1000}\)</td> <td style="text-align: left">\(\log^2n\)</td> <td style="text-align: left">\(\log{n^n} = n\log{n}, n^2, 2^{\log{n}} = n, n^{\sqrt{2}}\)</td> <td style="text-align: left">\(n^n, n^{\log{n}}, 2^n\)</td> </tr> </tbody> </table> <p>For the polynomial functions, we immediately know that \(n \lt n^{\sqrt{2}} \lt n^2\). For \(n\log{n}\), we can factor out \(n\) from all \(4\) functions and since we know that constant \(\lt\) logarithmic \(\lt\) polynomial functions, then the final ordering is \(n \lt n\log{n} \lt n^{\sqrt{2}} \lt n^2\).</p> <p>For the exponential functions, we can compare them by taking the \(\log\) of every function. We can do this because \(\log\) is an order-preserving function. So, we get \(n\log{n}, \log^2n, n\). We can easily order these functions and get \(n^{\log{n}} \lt 2^n \lt n^n\).</p> <p>So, the overall ordering of functions is \(2^{1000} \lt \log^2n \lt 2^{\log{n}} \lt \log{n^n} \lt n^{\sqrt{2}} \lt n^2 \lt n^{\log{n}} \lt 2^n \lt n^n\).</p> <h3 id="properties">Properties</h3> <p>\(O, \Omega, \Theta\) are all <strong>reflexive</strong> [\(f(n) \in O(f(n))\)] and <strong>transitive</strong> [if \(f(n) \in O(g(n))\) and \(g(n) \in O(h(n))\), then \(f(n) \in O(h(n))\)]. \(\Theta\) is also <strong>symmetric</strong> [if \(f(n) \in \Theta(g(n))\), then \(g(n) \in \Theta(f(n))\)].</p> <p>Let \(f(n)\) and \(g(n)\) be non-negative functions. We want to prove that \(O(f(n) + g(n)) = O(\max(f(n), g(n)))\). To show that two sets are equal, we must show that both are subsets of one another.</p> <ol> <li> <strong>Claim: If \(h(n) \in O(f(n) + g(n))\), then \(h(n) \in O(\max(f(n), g(n)))\).</strong> <ul> <li>Using the formal definition, we know that there exists a positive \(c, n_0\) where for any \(n &gt; n_0\), we have \(0 \leq h(n) \leq c \cdot (f(n) + g(n))\). Since \(f(n) + g(n) \leq 2 \cdot \max(f(n), g(n))\), it follows that \(0 \leq h(n) \leq 2c \cdot \max(f(n), g(n))\). Let \(c' = 2c, n' = n_0\), then by the formal definition, we can conclude that \(h(n) \in O(\max(f(n), g(n)))\).</li> </ul> </li> <li> <strong>Claim: If \(h(n) \in O(\max(f(n), g(n)))\), then \(h(n) \in O(f(n) + g(n))\).</strong> <ul> <li>The formal definition tells us that there exists a positive \(c, n_0\) where for any \(n &gt; n_0\), we have \(0 \leq h(n) \leq c \cdot \max(f(n), g(n))\). Since \(\max(f(n), g(n)) \leq f(n) + g(n)\), it follows that \(0 \leq h(n) \leq c \cdot f(n) + g(n)\). Let \(c' = c, n' = n_0\), then by the formal definition, we can conclude that \(h(n) \in O(f(n) + g(n))\).</li> </ul> </li> </ol> <p>Since we’ve proven both are subsets of one another, we can conclude that \(O(f(n) + g(n)) = O(\max(f(n), g(n)))\).</p> <p>To conduct <strong>runtime analysis</strong>, we can follow these steps:</p> <ol> <li>Given an algorithm and input of size \(n\), express the runtime as a function of \(n\), \(T(n)\).</li> <li>Derive a closed form expression for \(T(n)\) if necessary.</li> <li>Apply asymptotic notation to \(T(n)\) to obtain its order of growth.</li> </ol> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shrinking_array_max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># c_1
</span>    <span class="k">while</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">l</span><span class="p">]))</span> <span class="c1"># c_4 (n / 2^i)
</span>        <span class="n">l</span> <span class="o">/=</span> <span class="mi">2</span> <span class="c1"># c_2
</span>        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># c_3
</span>            <span class="k">break</span>
    <span class="k">return</span>
</code></pre></div></div> <p>For the above function, we can see that it consists of constant time operations \(c_1, c_2, c_3\) inside and outside of the while loop as well as a linear-time <code>max</code> operation. It’s important to note that because \(l\) is halved at every iteration, the size of the input array for <code>max</code> is also halved. It follows that the runtime for the max operation is actually \(c_4 \cdot \frac{n}{2^i}\), where \(i\) corresponds to the number of times \(l\) has been halved. We know that the number of times \(n\) can be halved is \(\log{n}\). So, in summary, we have the following:</p> \[\begin{aligned} T(n) &amp;= c_1 + \sum_{i = 0}^{\log{n}} (c_2 + c_3 + c_4 \frac{n}{2^i}) \\ &amp;= c_1 + \sum_{i = 0}^{\log{n}} (c_5 + c_4 \frac{n}{2^i}) \\ &amp;= c_6 + c_5 \log{n} + \sum_{i = 0}^{\log{n}} c_4 \frac{n}{2^i} \\ &amp;&lt; c_6 + c_5 \log{n} + c_4 n \sum_{i = 0}^\infty \frac{1}{2^i} \\ &amp;= c_6 + c_5 \log{n} + 2 c_4 n \end{aligned}\] <p>Now, we can apply asymptotic notation, giving us \(T(n) = O(n)\).</p> <h2 id="graphs">Graphs</h2> <dl> <dt>graph</dt> <dd>a <strong>graph</strong> \(G = (V, E)\) is a collection of <strong>vertices</strong> \(V\) of size \(n\) and <strong>edges</strong> \(E\) of size \(m\)</dd> <dt>degree</dt> <dd>in an <strong>undirected graph</strong>, the <strong>degree</strong> of a vertex is the number of edges for which it is an endpoint</dd> </dl> <p><strong>Claim: The sum of degrees of all vertices in a graph is twice the number of edges.</strong> We can prove this with a loop invariant, where after \(i\) iterations, the sum of degrees for all vertices is \(2i\).</p> <h3 id="graph-representation">Graph Representation</h3> <dl> <dt>adjacency matrix</dt> <dd>an <strong>adjacency matrix</strong> is a \(n \times n\) matrix \(A\) where \(A_{u, v} = 1\) if \((u, v)\) is an edge</dd> </dl> <p>An adjacency matrix has two representations for each edge of an undirected graph (\(A_{u, v} = A_{v, u}\)). Its spatial complexity is proportional to \(n^2\). We can check if \((u, v)\) is an edge in \(\Theta(1)\) time, but iterating through all the edges takes \(\Theta(n^2)\) time.</p> <dl> <dt>adjacency list</dt> <dd>an <strong>adjacency list</strong> is a node-indexed array of lists</dd> </dl> <p>An adjacency list also has two representations for each edge, but only requires \(\Theta(m + n)\) space. We can check if \((u, v)\) is an edge in \(O(degree(u))\) time and identify all edges in \(\Theta(m + n)\) time.</p> <dl> <dt>path</dt> <dd>a <strong>path</strong> in an undirected graph \(G = (V, E)\) is a sequence of nodes \(v_1, v_2, ..., v_k\) where each consecutive pair \(v_{i - 1}, v_i\) is joined by an edge \((v_{i - 1}, v_i) \in E\)</dd> </dl> <p>We say that a graph is <strong>connected</strong> if there exists a path between every pair of nodes \(u\) and \(v\).</p> <dl> <dt>cycle</dt> <dd>a <strong>cycle</strong> is a path \(v_1, v_2, ..., v_k\) in which \(v_1 = v_k\) and \(k ≥ 2\)</dd> <dt>tree</dt> <dd>an undirected graph is a <strong>tree</strong> if it is connected and does not contain a cycle</dd> </dl> <p><strong>Claim: A tree on \(n\) vertices has exactly \(n - 1\) edges for all \(n\) greater than or equal to \(1\).</strong> We can prove this with induction.</p> <ul> <li> <strong>Base Case:</strong> For \(n = 1\), the tree has \(n - 1 = 0\) edges.</li> <li> <strong>Inductive Hypothesis:</strong> Suppose that a tree on \(n\) vertices has exactly \(n - 1\) edges for some \(n \geq 1\).</li> <li> <strong>Inductive Step:</strong> Then, for the \(n + 1\) case, we want to show that a tree \(T\) on \(n + 1\) vertices has exactly \(n\) edges. Let us pick a leaf node \(v\), which is a vertex with degree \(1\). If we remove \(v\) and the edge \(e\) that connects it to the rest of the tree, we obtain a graph \(T'\) with \(n\) vertices. We know that \(T'\) is also a tree because removing an edge and vertex doesn’t create a cycle and \(T'\) is trivially connected. Since \(T'\) is a tree on \(n\) vertices, then by the inductive hypothesis, \(T'\) has exactly \(n - 1\) edges. Now, we readd the \(v\) and \(e\) from before to obtain \(T\). So, \(T\) has \((n - 1) + 1 = n\) edges and we have proven the \(n + 1\) case.</li> </ul> <p>Thus, by induction we have shown that a tree on \(n\) vertices has exactly \(n - 1\) edges for all \(n\) greater than or equal to \(1\).</p> <p><strong>Claim: Let \(G\) be an undirected graph on \(n\) nodes. Then, any two of the following implies the third: (1) \(G\) is connected, (2) \(G\) does not contain a cycle, (3) \(G\) has \(n – 1\) edges.</strong></p> <h3 id="graph-traversals">Graph Traversals</h3> <dl> <dt>breadth first search</dt> <dd>a <strong>breadth first search</strong> explores the graph from the starting node \(s\) in all possible directions and finds nodes level by level</dd> </dl> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Breadth First Search}
\begin{algorithmic}
\STATE mark $s$ as visited and the rest unvisited
\STATE set level[$0$] $=$ \{$s$\} and $i = 0$
\WHILE{level[$i$] is not empty}
    \STATE initialize level[$i + 1$] as an empty list
    \FOR{vertices $u$ in level[$i$]}
        \FOR{neighbors $v$ of $u$}
            \IF{$v$ has not been visited}
                \STATE mark $v$ as visited
                \STATE add $v$ to level[$i + 1$]
            \ENDIF
        \ENDFOR
    \ENDFOR
    \STATE increment $i$
\ENDWHILE
\end{algorithmic}
\end{algorithm}
</code></pre> <p>Breadth first search runs in \(O(m + n)\) time. We can arrive at this fact by observing that the outer <code>for</code> loop will execute \(n\) times, since each vertex appears in only one level and the inner <code>for</code> loop will execute \(2m\) times, since \(\sum_{v \in V} degree(v) = 2m\).</p> <dl> <dt>depth first search</dt> <dd>a <strong>depth first search</strong> explores the graph in one direction as far as possible before backtracking</dd> </dl> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Depth First Search}
\begin{algorithmic}
\STATE mark all nodes as unvisited
\STATE initialize stack to only contain $s$
\WHILE{stack is not empty}
    \STATE pop from the stack to obtain $u$
    \IF{u has not been discovered}
        \STATE mark $u$ as discovered
        \FOR{neighbors $v$ of $u$}
            \STATE push $v$ onto stack
        \ENDFOR
    \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}
</code></pre> <p>Depth first search also runs in \(O(m + n)\) time.</p> <dl> <dt>connected component</dt> <dd>the <strong>connected component</strong> of \(s\) are all the nodes reachable from \(s\)</dd> </dl> <p>To do graph induction proofs, we can use the following template:</p> <ol> <li>Start from \(G\) that satisfies the premise.</li> <li>Perform graph operations on \(G\) and obtain \(G'\) such that the premise of the inductive hypothesis holds for \(G'\).</li> <li>By the inductive hypothesis, the claim holds for \(G'\).</li> <li>Reconstruct \(G\) from \(G'\) and show that the claim also holds for \(G\).</li> </ol> <dl> <dt>bipartite</dt> <dd>a graph is <strong>bipartite</strong> if its vertices can be partitioned into two sets \(L\) and \(R\) such that (1) \(L \cup R = V\), (2) \(L \cap R = \emptyset\), (3) every edge has one end in \(L\) and the other in \(R\)</dd> </dl> <p>We can also show that a graph is bipartite if and only if it is two-<strong>colorable</strong> and contains no odd length cycles.</p> <p><strong>Claim: A graph is bipartite if and only if it is two-colorable.</strong></p> <ul> <li>(→) We want to prove that if a graph is bipartite, then it is two-colorable. We know that \(V\) can be partitioned into \(L\) and \(R\), which we can color blue and green, respectively. Since all edges \(e \in E\) have one end in \(L\) and the other in \(R\), then all edges are not monochromatic and thus we can conclude that the graph is two-colorable.</li> <li>(←) We want to prove that if a graph is two-colorable, then it is bipartite. Without loss of generality, we can assign \(L\) to be blue vertices and \(R\) to be green vertices. Since there are no monochromatic edges, all edges have one end in \(L\) and the other in \(R\) and thus we can conclude that the graph is bipartite.</li> </ul> <p><strong>Claim: A graph is bipartite if and only if it does not contain an odd length cycle.</strong></p> <ul> <li>(→) We want to prove that if a graph is bipartite, then it does not contain an odd length cycle. By our previous result, \(G\) is also two-colorable. Now, suppose we have a \(k\)-length cycle in \(G\), \((v_0, v_1, ..., v_k)\). Let’s color the vertices at even indices blue and at odd indices green. Since this is a cycle, \(v_0 = v_k\) and they must have the same color. \(v_0\) is colored blue, so \(v_k\) must also be blue, which implies that \(k\) is even. Thus, for any arbitrary cycle in \(G\), it must be of even length.</li> <li>(←) We want to prove that if a graph does not contain an odd length cycle, then it is bipartite. Let’s pick an arbitrary \(v \in V\) and use breadth first search to partition the vertices into \(L\) and \(R\) according to the evenness of their distance from \(v\). A vertex is in \(L\) if the distance is even, otherwise it is in \(R\). Now color vertices in \(L\) blue and vertices in \(R\) green. We want to show that no monochromatic edge exists and we can do so by contradiction. Suppose a monochromatic edge \(e = (u', v')\) does exist. Without loss of generality, let \(u', v' \in L\), then both are even distances away from \(v\). If we connect the path from \(u'\) to \(v\), the path from \(v'\) to \(v\), and \(e\), we obtain an odd length cycle. However, this contradicts our original assumption and so we have shown that such a monochromatic edge could not exist. Thus, \(G\) is bipartite.</li> </ul> <dl> <dt>strong connectivity</dt> <dd>a graph is <strong>strongly connected</strong> if there exists a path from \(u\) to \(v\) and \(v\) to \(u\) for every pair of nodes \(u, v\)</dd> <dt>directed acyclic graphs</dt> <dd>a <strong>directed acyclic graph</strong> or <strong>DAG</strong> is a directed graph that contains no directed cycle</dd> <dt>topological order</dt> <dd>a <strong>topological order</strong> of a directed graph \(G = (V, E)\) is an ordering of its nodes \(v_1, v_2, ..., v_n\) such that for every edge \((v_i, v_j)\) in \(G\), we have \(i &lt; j\)</dd> </dl> <p><strong>Claim: If \(G\) has a topological order, then \(G\) is a DAG.</strong> We can prove this by contradiction. Suppose \(G\) has a topological order \(v_1, v_2, ..., v_i, ..., v_j, ..., v_n\), but \(G\) is not a DAG. This means that there exists some directed cycle \((v_i, ..., v_j, v_i)\) for some \(i &lt; j\). However, we have an edge \((v_j, v_i)\), where \(j &gt; i\). Thus, we have contradicted one of the criteria of a topological order and so we can conclude that \(G\) has to be a DAG.</p> <p><strong>Claim: If \(G\) is a DAG, then \(G\) has a topological ordering.</strong> We can prove this by induction over \(n\) the number of vertices.</p> <ul> <li> <strong>Base Case:</strong> For \(n = 1\), it is trivial that the graph \(G\) is a DAG and has a topological ordering.</li> <li> <strong>Inductive Hypothesis:</strong> Suppose that the statement holds for some \(n \geq 1\). In other words, if a graph with \(n\) vertices \(G\) is a DAG, then it has a topological ordering.</li> <li> <strong>Inductive Step:</strong> For the \(n + 1\) case, we want to show that if a graph with \(n + 1\) vertices \(G\) is a DAG, then it has a topological ordering. Because \(G\) is a DAG, we know there exists a node with in-degree \(0\). Let’s remove node \(v\) and its associated edges to obtain \(G' = G - \{v\}\). \(G'\) is a graph with \(n\) vertices. Because removing a node and its edges does not create any cycles, we know that \(G'\) is still a DAG. Our inductive hypothesis tells us that \(G'\) has a topological ordering. Now, we can add \(v\) back to obtain \(G\) and prepend it to the topological ordering of \(G'\), resulting in a topological ordering of \(G\).</li> </ul> <p>Thus, by induction, we have shown that if \(G\) is a DAG, then \(G\) has a topological ordering.</p> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Topological Ordering}
\begin{algorithmic}
\STATE find a node $v$ with no incoming edges and order it first
\STATE delete $v$ from $G$
\STATE recursively compute a topological ordering of $G - $\{$v$\} and append this order after $v$
\end{algorithmic}
\end{algorithm}
</code></pre> <h2 id="greedy-algorithms">Greedy Algorithms</h2> <h3 id="interval-scheduling">Interval Scheduling</h3> <dl> <dt>interval scheduling</dt> <dd>an <strong>interval scheduling</strong> problem is as follows – given a set of jobs, where job \(j\) has a start \(s_j\) and finish \(f_j\) time, we want to find the maximum subset of jobs where no two jobs overlap</dd> </dl> <p>One attempt could be to consider scheduling jobs with the earliest start time. However, we can see in the following case that selecting with this criteria would not result in the optimal solution.</p> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-center align-items-center w-75"> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[green, fill=green!50] (-4, 0.5) rectangle (4, 0.1);
            \node[text=black!50!green] at (0, 0.3) {$1$};
            \draw[gray, fill=gray!50] (-3, -0.1) rectangle (-2, -0.5);
            \node[text=black!50!gray] at (-2.5, -0.3) {$2$};
            \draw[gray, fill=gray!50] (-1, -0.1) rectangle (1, -0.5);
            \node[text=black!50!gray] at (0, -0.3) {$3$};
            \draw[gray, fill=gray!50] (2, -0.1) rectangle (3, -0.5);
            \node[text=black!50!gray] at (2.5, -0.3) {$4$};
        \end{tikzpicture}
        </script> </div> </div> <p>Another attempt schedules jobs with the smallest interval first. However, we can also find a counterexample like below.</p> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-center align-items-center w-75"> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[green, fill=green!50] (-1, 0.5) rectangle (1, 0.1);
            \node[text=black!50!green] at (0, 0.3) {$1$};
            \draw[gray, fill=gray!50] (-4, -0.1) rectangle (-0.5, -0.5);
            \node[text=black!50!gray] at (-2.25, -0.3) {$2$};
            \draw[gray, fill=gray!50] (0.5, -0.1) rectangle (4, -0.5);
            \node[text=black!50!gray] at (2.25, -0.3) {$3$};
        \end{tikzpicture}
        </script> </div> </div> <p><strong>Claim: Scheduling by earliest finish time is the optimal solution.</strong> We can prove this by contradiction. Suppose the scheduling \(S\) produced by this algorithm is not optimal. Let \(i_1, ..., i_k\) be jobs in \(S\). Let \(j_1, ..., j_m\) be jobs in the optimal solution \(S^*\). So, \(m &gt; k\). Now, let \(r\) be the largest number such that \(S\) and \(S^*\) are the same. Since \(S\) is ordered by earliest finish time, we know that \(f_{j_{r + 1}} \geq f_{i_{r + 1}}\). It follows that we can swap \(j_{r + 1}\) for \(i_{r + 1}\) in \(S^*\) while maintaining its optimality. However, this means that \(r\) was not the largest number such that \(S\) and \(S^*\) are in common and thus we have a contradiction and have shown that scheduling by the earliest finish time is optimal.</p> <dl> <dt>interval partitioning</dt> <dd>an <strong>interval partitioning</strong> problem is as follows – given a set of lectures, where lecture \(j\) starts at \(s_j\) and finishes at \(f_j\), find the minimum number of classrooms to schedule all lectures such that no two lectures occur at the same time in the same room</dd> </dl> <p>Here, we can’t use the earliest finish time algorithm to schedule. A counterexample is shown below.</p> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-center align-items-center w-75"> <script type="text/tikz">
        \begin{tikzpicture}
            \draw[gray, fill=gray!50] (-4, 0.4) rectangle (0.5, 0);
            \node[text=black!50!gray] at (-1.75, 0.2) {$a$};
            \draw[gray, fill=gray!50] (-4, 1.0) rectangle (1.5, 0.6);
            \node[text=black!50!gray] at (-1.25, 0.8) {$b$};
            \draw[gray, fill=gray!50] (1, 1.6) rectangle (4, 1.2);
            \node[text=black!50!gray] at (2.5, 1.4) {$c$};
            \draw[gray, fill=gray!50] (2, 0.4) rectangle (3, 0);
            \node[text=black!50!gray] at (2.5, 0.2) {$d$};
        \end{tikzpicture}
        </script> </div> </div> <h3 id="dijkstras-algorithm">Dijkstra’s Algorithm</h3> <dl> <dt>single-pair shortest path</dt> <dd>given a digraph \(G = (V, E)\), positive edge lengths \(l_e\), source \(s \in V\), and destination \(t \in V\), find a shortest directed path from \(s\) to \(t\)</dd> </dl> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Dijkstra's Algorithm}
\begin{algorithmic}
\STATE create an empty priority queue q
\STATE set dist[$s$] = $0$
\STATE add ($s$, $0$) to q
\FOR{$v$ != $s$}
    \STATE set dist[$v$] = $\infty$, pred[$v$] = NULL
    \STATE add ($v$, $\infty$) to q
\ENDFOR
\WHILE{$q$ is not empty}
    \STATE pop q to get $u$
    \FOR{neighbors $v$ of $u$}
        \IF{dist[$u$] + $l_e &lt;$ dist[$v$]}
            \STATE set pred[$v$] = $u$
            \STATE set dist[$v$] = dist[$u$] + $l_e$
            \STATE decrease priority in q for $v$ to dist[$v$]
        \ENDIF
    \ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}
</code></pre> <h3 id="mininum-spanning-trees">Mininum Spanning Trees</h3> <dl> <dt>cut</dt> <dd>a <strong>cut</strong> is a partition of the nodes into two nonempty subsets \(S\) and \(V - S\)</dd> <dt>cutset</dt> <dd>a <strong>cutset</strong> of a cut \(S\) is the set of all edges with exactly one endpoint in \(S\)</dd> <dt>spanning tree</dt> <dd>a <strong>spanning tree</strong> of \(G\) is a subgraph that is a tree and contains all vertices</dd> </dl> <p>Let \(H = (V, T)\) be a subgraph of an undirected graph \(G = (V, E)\). Then, the following are equivalent:</p> <ul> <li>\(H\) is a <strong>spanning tree</strong> of \(G\)</li> <li>\(H\) is acyclic and connected</li> <li>\(H\) is connected and has \(\mid V \mid - 1\) edges</li> <li>\(H\) is acyclic and has \(\mid V \mid - 1\) edges</li> <li>\(H\) is minimally connected (i.e. removal of any edge disconnects it)</li> <li>\(H\) is maximally acyclic (i.e. adding any edge creates a cycle)</li> </ul> <dl> <dt>minimum spanning tree</dt> <dd>a <strong>minimum spanning tree</strong> is a spanning tree with the minimum sum of edge weights</dd> </dl> <p><strong>Claim: For any cycle in \(G\), the maximum cost edge in the cycle is not in any MST of \(G\).</strong></p> <p><strong>Claim: For any cut of \(G\), the minimum cost edge spanning the cut must be contained in every MST.</strong> We can prove this by contradiction. Assume that there exists a MST \(T\), where this minimum cost edge \(e\) is not contained in \(T\). Let \(u \in S\) and \(v \in V - S\). Since \(T\) is a spanning tree, we know that there exists a path from \(u\) to \(v\) using an edge \(e^*\) that spans the cut. Let \(T' = T - \{e^*\} + \{e\}\). Replacing edge \(e^*\) with \(e\) maintains connectivity because they both span the cut. Removing and adding an edge also does not create a cycle. It follows that \(T'\) is still a spanning tree. However, the cost of \(T'\) is less than \(T\) because \(e^* &gt; e\). This is a contradiction to our assumption that \(T\) is the minimum spanning tree. Thus, we have shown that for any cut of \(G\), the minimum cost edge spanning the cut must be contained in every MST.</p> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Prim's Algorithm}
\begin{algorithmic}
\STATE initialize $S = \{s\}$ for an arbitrary node $s$
\STATE set $T = \emptyset$
\FOR{$n - 1$ iterations}
    \STATE add to $T$ a min-cost edge with exactly one endpoint in $S$
    \STATE add the other endpoint to $S$
\ENDFOR
\end{algorithmic}
\end{algorithm}
</code></pre> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Kruskal's Algorithm}
\begin{algorithmic}
\STATE sort edges in ascending order of cost
\FOR{edges $e$}
    \STATE add to tree $T$ unless doing so creates a cycle
\ENDFOR
\end{algorithmic}
\end{algorithm}
</code></pre> <h2 id="divide-and-conquer">Divide and Conquer</h2> <dl> <dt>divide and conquer</dt> <dd>a <strong>divide and conquer</strong> strategy divides problems up into smaller subproblems, solves subproblems recursively, and combines subproblem solutions to obtain the overall solution</dd> </dl> <p>For the problem setting of sorting, <strong>mergesort</strong> is an example of a divide and conquer approach. In merge sort, we recursively sort the left and right halves and merge the subresults in linear time. This linear time merging is done by scanning both sorted lists \(A\) and \(B\) from left to right and appending whichever top element is smaller.</p> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Merge Sort}
\begin{algorithmic}
\PROCEDURE{Mergesort}{$L$}
\IF{list $L$ has only one element}
    \STATE return
\ENDIF
\STATE divide list $L$ into two halves $A$ and $B$
\STATE sort list $A$ with \CALL{Mergesort}{$A$}
\STATE sort list $B$ with \CALL{Mergesort}{$B$}
\STATE return \CALL{Merge}{$A$, $B$}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre> <p><strong>Claim: If \(T(n)\) satisfies \(T(n) = 2 T(\frac{n}{2}) + n\) where \(T(1) = 0\), then \(T(n) = n \log n\).</strong> Let’s first visualize this algorithm with a <strong>recursion tree</strong>. </p> <div align="center" class="pb-4"> <div class="d-flex flex-wrap flex-md-row flex-column justify-content-center align-items-center w-75"> <script type="text/tikz">
        \begin{tikzpicture}
            \node[black!25] at (-5, -2) {$\log n$ levels};
            \draw[black!25, -|] (-5, -1.75) -- (-5, 0);
            \draw[black!25, -|] (-5, -2.25) -- (-5, -4);

            \draw[red!60, fill=red!25] (0, 0) circle (0.75);
            \node[text=black!50!red] at (0, 0) {$T(n)$};

            \node[black!25] at (5, 0) {$n$};

            \draw[red, dotted, thick, ->] (-0.75, -0.75) -- (-1.25, -1.25);
            \draw[red, dotted, thick, ->] (0.75, -0.75) -- (1.25, -1.25);

            \draw[red!60, fill=red!25] (-2, -2) circle (0.75);
            \node[text=black!50!red] at (-2, -2) {$T(\frac{n}{2})$};
            \draw[red!60, fill=red!25] (2, -2) circle (0.75);
            \node[text=black!50!red] at (2, -2) {$T(\frac{n}{2})$};

            \node[black!25] at (5, -2) {$2 \cdot \frac{n}{2} = n$};

            \draw[red, dotted, thick, ->] (-2.5, -2.8) -- (-2.75, -3.1);
            \draw[red, dotted, thick, ->] (-1.5, -2.8) -- (-1.25, -3.1);
            \draw[red, dotted, thick, ->] (2.5, -2.8) -- (2.75, -3.1);
            \draw[red, dotted, thick, ->] (1.5, -2.8) -- (1.25, -3.1);

            \draw[red!60, fill=red!25] (-3, -4) circle (0.75);
            \node[text=black!50!red] at (-3, -4) {$T(\frac{n}{4})$};
            \draw[red!60, fill=red!25] (-1, -4) circle (0.75);
            \node[text=black!50!red] at (-1, -4) {$T(\frac{n}{4})$};
            \draw[red!60, fill=red!25] (1, -4) circle (0.75);
            \node[text=black!50!red] at (1, -4) {$T(\frac{n}{4})$};
            \draw[red!60, fill=red!25] (3, -4) circle (0.75);
            \node[text=black!50!red] at (3, -4) {$T(\frac{n}{4})$};

            \node[black!25] at (5, -4) {$4 \cdot \frac{n}{4} = n$};
        \end{tikzpicture}
        </script> </div> </div> <p>We can see that at every level the work being done is \(n\) and since there are \(\log n\) levels, the runtime is \(T(n) = n \log n\).</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># c_1
</span>    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span> <span class="c1"># c_2
</span>        <span class="k">return</span> <span class="n">m</span> <span class="c1"># c_3
</span>    <span class="k">elif</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]:</span> <span class="c1"># c_4
</span>        <span class="k">return</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="n">m</span><span class="p">],</span> <span class="n">target</span><span class="p">)</span> <span class="c1"># T(n / 2)
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">bsearch</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">target</span><span class="p">)</span> <span class="c1"># T(n / 2)
</span></code></pre></div></div> <p>For the above function, we can see that each <code class="language-plaintext highlighter-rouge">py bsearch</code> function call does constant work and recursively calls itself for an additional \(T(\frac{n}{2})\) amount of work. Thus, the recurrence relation is:</p> \[T(n) = T(\frac{n}{2}) + c\] <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Counting Inversions}
\begin{algorithmic}
\PROCEDURE{SortAndCount}{$L$}
\IF{list $L$ has only one element}
    \STATE return ($0$, $L$)
\ENDIF
\STATE divide list $L$ into two halves $A$ and $B$
\STATE sort list $A$ with \CALL{SortAndCount}{$A$} to obtain ($r_A, A$)
\STATE sort list $B$ with \CALL{SortAndCount}{$B$} to obtain ($r_B, B$)
\STATE \CALL{MergeAndCount}{$A$, $B$} to obtain ($r_{AB}$, $L$)
\STATE return ($r_A + r_B + r_{AB}$, $L$)
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Closest Pair}
\begin{algorithmic}
\PROCEDURE{ClosestPair}{p$_1$, p$_2$, ..., p$_n$}
\STATE compute vertical line $L$ such that it splits points in half
\STATE $d_1$ = \CALL{ClosestPair}{points in left half}
\STATE $d_2$ = \CALL{ClosetsPair}{points in right half}
\STATE $d$ = min($d_1$, $d_2$)
\STATE $A$ = list of all points closer than $d$ to line $L$
\STATE sort $A$ by y-coordinates
\STATE scan $A$ in y-order, compare distance between each point and next $7$ neighbors, and update $d$ if smaller distance
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre> <h3 id="master-theorem">Master Theorem</h3> <p>The general <strong>recurrence relation</strong> for a divide and conquer approach is:</p> \[T(n) = a T(\frac{n}{b}) + f(n)\] <p>\(a \geq 1\) is the number of subproblems, \(b \geq 2\) is the factor by which the subproblem size decreases, and \(f(n) \geq 0\) is the work required to divide and combine subproblems. In the corresponding recursion tree, \(a\) is the <strong>branching factor</strong>, \(a^i\) is the number of subproblems at level \(i\) (root is level \(0\)), there are \(1 + \log_{b} n\) levels, and \(\frac{n}{b^i}\) is the size of subproblems at level \(i\).</p> <p>Suppose that \(T(n)\) is a function that satisfies the relation:</p> \[T(n) = a T(\frac{n}{b}) + \Theta(n^c)\] <p>Here, \(T(0) = 0\) and \(T(1) = \Theta(1)\). Then, the <strong>master theorem</strong> tells us the following:</p> <ul> <li> <strong>Case 1:</strong> If \(c \gt \log_{b} a\), then \(T(n) = \Theta(n^c)\).</li> <li> <strong>Case 2:</strong> If \(c = \log_{b} a\), then \(T(n) = \Theta(n^c \log n)\).</li> <li> <strong>Case 3:</strong> If \(c \lt \log_{b} a\), then \(T(n) = \Theta(n^{\log_{b} a})\).</li> </ul> <h2 id="dynamic-programming">Dynamic Programming</h2> <dl> <dt>dynamic programming</dt> <dd>a <strong>dynamic programming</strong> approach breaks up the original problem into overlapping subproblems and combines smaller subproblems to form solution for the larger problem</dd> </dl> <h3 id="weighted-interval-scheduling">Weighted Interval Scheduling</h3> <dl> <dt>weighted interval scheduling</dt> <dd>a <strong>weighted interval scheduling</strong> problem is an extension of the interval scheduling problem, where each job now has a weight \(w_j\) and the goal is to find the optimal subset of mutually compatible jobs, such that the total weight is maximized</dd> </dl> <p>We can solve this with dynamic programming. First, sort the jobs in ascending order based on their finish times. Define \(p(j)\) as the largest index \(i &lt; j\) such that job \(i\) is compatible with \(j\). Also, define \(OPT(j)\) as the maximum weight of any subset of mutually compatible jobs for subproblem consisting only of jobs \(1, 2, ..., j\). It follows that our goal is to determine \(OPT(n)\). When it comes to evaluating \(OPT(j)\), there are two cases:</p> <ul> <li> <strong>Case 1:</strong> \(OPT(j)\) does not select job \(j\), then the optimal solution is \(OPT(j - 1)\).</li> <li> <strong>Case 2:</strong> \(OPT(j)\) selects job \(j\), then the optimal solution is \(w_j + OPT(p(j))\).</li> </ul> <p>Now, we can write out the <strong>bellman equation</strong> as follows:</p> \[OPT(j) = \begin{cases} 0 &amp; \text{if } j = 0 \\ \max\{OPT(j - 1), w_j + OPT(p(j))\} &amp; \text{if } j &gt; 0 \end{cases}\] <dl> <dt>memoization</dt> <dd> <strong>memoization</strong> or <strong>top-down dynamic programming</strong> is a recursive approach that caches results of smaller subproblems</dd> <dt>tabulation</dt> <dd> <strong>tabulation</strong> or <strong>bottom-up dynamic programming</strong> is a iterative approach that tabulates previous results</dd> </dl> <h3 id="knapsack-problem">Knapsack Problem</h3> <dl> <dt>knapsack problem</dt> <dd>in the <strong>knapsack problem</strong>, we are given \(n\) items each with a value \(v_i \gt 0\) and a weight \(w_i \gt 0\), and we want to maximize the total value of items taken under the constraint that the knapsack has a total weight limit \(W\)</dd> </dl> <p>To use dynamic programming, we can define \(OPT(i, w)\) as the maximum value of items taken from items \(1, ..., i\) subject to the weight limit \(w\). It follows that our objective is to compute \(OPT(n, W)\). To evaluate \(OPT(i, w)\), there are two cases:</p> <ul> <li> <strong>Case 1:</strong> \(OPT(i, w)\) does not select item \(i\), then the optimal solution is \(OPT(i - 1, w)\).</li> <li> <strong>Case 2:</strong> \(OPT(i, w)\) selects item \(i\), then the optimal solution is \(OPT(i - 1, w - w_i)\).</li> </ul> <p>Now, we can write out the bellman equation as follows:</p> \[OPT(i, w) = \begin{cases} 0 &amp; \text{if } i = 0 \\ OPT(i - 1, w) &amp; \text{if } w_i &gt; w \\ \max\{OPT(i - 1, w), v_i + OPT(i - 1, w - w_i)\} &amp; \text{otherwise} \end{cases}\] <h3 id="rna-secondary-structure">RNA Secondary Structure</h3> <dl> <dt>secondary structure</dt> <dd>a valid <strong>secondary structure</strong> is a set of pairs \(S = {(b_i, b_j)}\) that satisfies (1) \(S\) is a matching and each pair in \(S\) is either \(A-U\), \(U-A\), \(C-G\), or \(G-C\), (2) if \((b_1, b_j) \in S\), then \(i &lt; j - 4\), (3) if \((b_i, b_j)\) and \((b_k, b_l)\) are two pairs in \(S\), then we cannot have \(i &lt; k &lt; j &lt; l\)</dd> </dl> <p>Our objective is to find a secondary structure with the minimum total free energy, which is achieved by maximizing the number of base pairs. Here, we can define \(OPT(i, j)\) as the maximum number of base pairs in a secondary structure of the substring \(b_i, b_{i + 1}, ..., b_j\). It follows that our goal is to figure out \(OPT(1, n)\). To compute \(OPT(i, j)\), there are three cases:</p> <ul> <li> <strong>Case 1:</strong> If \(i \leq j - 4\), \(OPT(i, j) = 0\) because of the no sharp turns constraint.</li> <li> <strong>Case 2:</strong> Base \(b_j\) is not involved in a pair, so the optimal solution is \(OPT(i, j - 1)\).</li> <li> <strong>Case 3:</strong> Base \(b_j\) pairs with \(b_t\) for some \(i \leq t \lt j - 4\) and the optimal solution is \(1 + \max_t \{OPT(i, t - 1) + OPT(t + 1, j - 1)\}\).</li> </ul> <h3 id="sequence-alignment">Sequence Alignment</h3> <dl> <dt>alignment</dt> <dd>an <strong>alignment</strong> \(M\) is a set of ordered pairs \(x_i-y_j\) such that each character appears in at most one pair and no crossings</dd> </dl> </article> <h2>References</h2> <div class="publications"> <h2 class="bibliography">2005</h2> <ol class="bibliography"><li> <div class="row"> <div class="col col-sm-2 abbr"> </div> <div id="10.5555/1051910" class="col-sm-8"> <div class="title">Algorithm Design</div> <div class="author"> Jon Kleinberg, and Eva Tardos </div> <div class="periodical"> Jul 2005 </div> <div class="periodical"> </div> <div class="links"> </div> </div> </div> </li></ol> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Joe Lin. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="/assets/libs/jquery/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="/assets/libs/mdb/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="/assets/libs/masonry/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="/assets/libs/imagesloaded/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script defer src="/assets/libs/medium_zoom/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/libs/bootstrap-table/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0}};</script> <script type="text/javascript" id="MathJax-script" src="/assets/libs/mathjax/tex-mml-chtml.min.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script type="text/javascript" src="/assets/libs/pseudocode/pseudocode.min.js" integrity="sha256-aVkDxqyzrB+ExUsOY9PdyelkDhn/DfrjWu08aVpqNlo=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-pseudocode").forEach(e=>{const t=e.textContent,d=e.parentElement.parentElement;let n=document.createElement("pre");n.classList.add("pseudocode");const o=document.createTextNode(t);n.appendChild(o),d.appendChild(n),d.removeChild(e.parentElement),pseudocode.renderElement(n)})});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"recent research works",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"a collection of academic and extracurricular projects in machine learning and web development!",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-notes",title:"notes",description:"collection of detailed notes and summaries from my academic courses",section:"Navigation",handler:()=>{window.location.href="/notes/"}},{id:"nav-cv",title:"cv",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-digital-humans",title:"digital humans",description:"a deep dive into representing and understanding humans",section:"Posts",handler:()=>{window.location.href="/blog/2024/digital-humans/"}},{id:"news-lt-strong-gt-learning-to-generate-diverse-pedestrian-movements-from-web-videos-with-noisy-labels-lt-strong-gt-is-accepted-to-lt-em-gt-iclr-2025-lt-em-gt",title:"&lt;strong&gt;Learning to Generate Diverse Pedestrian Movements from Web Videos with Noisy Labels&lt;/strong&gt; is accepted to &lt;em&gt;ICLR 2025&lt;/em&gt;.",description:"",section:"News"},{id:"news-lt-strong-gt-learning-assistant-lt-strong-gt-for-prof-bolei-zhou-s-cs-163",title:"&lt;strong&gt;Learning Assistant&lt;/strong&gt; for Prof. Bolei Zhou\u2019s CS 163!",description:"",section:"News"},{id:"news-joined-zhou-lab-at-ucla",title:"Joined Zhou Lab at UCLA.",description:"",section:"News"},{id:"notes-cs180-introduction-to-algorithms-and-complexity",title:"cs180 - introduction to algorithms and complexity",description:"course notes from summer &#39;24",section:"Notes",handler:()=>{window.location.href="/notes/cs180/"}},{id:"notes-cs188-deep-learning-for-computer-vision",title:"cs188 - deep learning for computer vision",description:"course notes from winter &#39;24",section:"Notes",handler:()=>{window.location.href="/notes/cs188/"}},{id:"projects-cifar-image-classification",title:"cifar image classification",description:"using popular deep learning architectures",section:"Projects",handler:()=>{window.location.href="/projects/cifar/"}},{id:"projects-autonomous-vehicle-expo",title:"autonomous vehicle expo",description:"eagle project conference website",section:"Projects",handler:()=>{window.location.href="/projects/conference/"}},{id:"projects-novel-view-synthesis",title:"novel view synthesis",description:"com sci 188 final project (w/ michael song and alexander chien)",section:"Projects",handler:()=>{window.location.href="/projects/novel_view_synthesis/"}},{id:"projects-abdominal-trauma-detection",title:"abdominal trauma detection",description:"rsna kaggle competition",section:"Projects",handler:()=>{window.location.href="/projects/rsna_atd/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%6A%6F%65%6C%69%6E%74%65%63%68@%75%63%6C%61.%65%64%75","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/joe-lin-tech","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/joe-lin-tech","_blank")}},{id:"socials-kaggle",title:"Kaggle",section:"Socials",handler:()=>{window.open("https://www.kaggle.com/16385395","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>